{
  "author": {
    "name": "Tom MacWright",
    "email": "tom@macwright.org",
    "url": "http://macwright.org/"
  },
  "name": "simple-statistics",
  "description": "Simple Statistics",
  "version": "0.8.1",
  "repository": {
    "type": "git",
    "url": "git://github.com/tmcw/simple-statistics.git"
  },
  "dependencies": {},
  "devDependencies": {
    "mocha": "1.17.x",
    "chai": "1.9.x",
    "jshint": "2.4.4"
  },
  "scripts": {
    "test": "jshint src/*.js && mocha -R spec test/spec",
    "api": "node api.js"
  },
  "main": "src/simple_statistics.js",
  "engines": {
    "node": "*"
  },
  "license": "BSD",
  "readme": "[![Build Status](https://secure.travis-ci.org/tmcw/simple-statistics.png?branch=master)](http://travis-ci.org/tmcw/simple-statistics)\n\nA JavaScript implementation of descriptive, regression, and inference statistics.\n\nImplemented in literate JavaScript with no dependencies, designed to work\nin all modern browsers (including IE) as well as in node.js.\n\n## [API Documentation](API.md)\n\n---\n\nBasic contracts of functions:\n\n* Functions do not modify their arguments e.g. change their order\n* Invalid input, like empty lists to functions that need 1+ items to work, will cause functions to return `null`.\n\n# Basic Array Operations\n\n### .mixin(array)\n\n_Optionally_ mix in the following functions into the `Array` prototype. Otherwise\nyou can use them off of the simple-statistics object itself.\n\nIf given a particular array instance as an argument, this adds the functions\nonly to that array rather than the global `Array.prototype`. Without an argument,\nit runs on the global `Array.prototype`.\n\n### .mean(x)\n\nMean of a single-dimensional Array of numbers. _Also available as `.average(x)`_\n\n### .sum(x)\n\nSum of a single-dimensional Array of numbers.\n\n### .variance(x)\n\n[Variance](http://en.wikipedia.org/wiki/Variance) of a single-dimensional Array of numbers.\n\n### .standard_deviation(x)\n\n[Standard Deviation](http://en.wikipedia.org/wiki/Standard_deviation) of a single-dimensional Array of numbers.\n\n### .median_absolute_deviation(x)\n\nThe Median Absolute Deviation (MAD) is a robust measure of statistical\ndispersion. It is more resilient to outliers than the standard deviation.\nAccepts a single-dimensional array of numbers and returns a dispersion value.\n\nAlso aliased to `.mad(x)` for brevity.\n\n### .median(x)\n\n[Median](http://en.wikipedia.org/wiki/Median) of a single-dimensional array of numbers.\n\n### .geometric_mean(x)\n\n[Geometric mean](http://en.wikipedia.org/wiki/Geometric_mean) of a single-dimensional array of **positive** numbers.\n\n### .harmonic_mean(x)\n\n[Harmonic mean](http://en.wikipedia.org/wiki/Harmonic_mean) of a single-dimensional array of **positive** numbers.\n\n### .min(x)\n\nFinds the minimum of a single-dimensional array of numbers. This runs in linear `O(n)` time.\n\n### .max(x)\n\nFinds the maximum of a single-dimensional array of numbers. This runs in linear `O(n)` time.\n\n### .t_test(sample, x)\n\nDoes a [student's t-test](http://en.wikipedia.org/wiki/Student's_t-test) of a dataset `sample`, represented by a single-dimensional array of numbers. `x` is the known value, and the result is a measure of [statistical significance](http://en.wikipedia.org/wiki/Statistical_significance).\n\n### .t_test_two_sample(sample_x, sample_y, difference)\n\nThe two-sample t-test is used to compare samples from two populations or groups,\nconfirming or denying the suspicion (null hypothesis) that the populations are\nthe same. It returns a t-value that you can then look up to give certain\njudgements of confidence based on a t distribution table.\n\nThis implementation expects the samples `sample_x` and `sample_y` to be given\nas one-dimensional arrays of more than one number each.\n\n### .sample_variance(x)\n\nProduces [sample variance](http://mathworld.wolfram.com/SampleVariance.html)\nof a single-dimensional array of numbers.\n\n### .sample_covariance(x)\n\nProduces [sample covariance](http://en.wikipedia.org/wiki/Sample_mean_and_sample_covariance)\nof two single-dimensional arrays of numbers.\n\n### .sample_correlation(x)\n\nProduces [sample correlation](http://en.wikipedia.org/wiki/Correlation_and_dependence)\nof two single-dimensional arrays of numbers.\n\n### .quantile(sample, p)\n\nDoes a [quantile](http://en.wikipedia.org/wiki/Quantile) of a dataset `sample`,\nat p. For those familiary with the `k/q` syntax, `p == k/q`. `sample` must\nbe a single-dimensional array of numbers. p must be a number greater than or equal to\nthan zero and less or equal to than one, or an array of numbers following that rule.\nIf an array is given, an array of results will be returned instead of a single\nnumber.\n\n### .quantile_sorted(sample, p)\n\nDoes a [quantile](http://en.wikipedia.org/wiki/Quantile) of a dataset `sample`,\nat p. `sample` must be a one-dimensional _sorted_ array of numbers, and\n`p` must be a single number from zero to one.\n\n### .iqr(sample)\n\nCalculates the [Interquartile range](http://en.wikipedia.org/wiki/Interquartile_range) of\na sample - the difference between the upper and lower quartiles. Useful\nas a measure of dispersion.\n\n_Also available as `.interquartile_range(x)`_\n\n### .sample_skewness(sample)\n\nCalculates the [skewness](http://en.wikipedia.org/wiki/Skewness) of\na sample, a measure of the extent to which a probability distribution of a\nreal-valued random variable \"leans\" to one side of the mean.\nThe skewness value can be positive or negative, or even undefined.\n\nThis implementation uses the [Fisher-Pearson standardized moment coefficient](http://en.wikipedia.org/wiki/Skewness#Pearson.27s_skewness_coefficients),\nwhich means that it behaves the same as Excel, Minitab, SAS, and SPSS.\n\nSkewness is only valid for samples of over three values.\n\n### .jenks(data, number_of_classes)\n\nFind the [Jenks Natural Breaks](http://en.wikipedia.org/wiki/Jenks_natural_breaks_optimization) for\na single-dimensional array of numbers as input and a desired `number_of_classes`.\nThe result is a single-dimensional with class breaks, including the minimum\nand maximum of the input array.\n\n### .r_squared(data, function)\n\nFind the [r-squared](http://en.wikipedia.org/wiki/Coefficient_of_determination) value of a particular dataset, expressed as a two-dimensional `Array` of numbers, against a `Function`.\n\n    var r_squared = ss.r_squared([[1, 1]], function(x) { return x * 2; });\n\n### .cumulative_std_normal_probability(z)\n\nLook up the given `z` value in a [standard normal table](http://en.wikipedia.org/wiki/Standard_normal_table)\nto calculate the probability of a random variable appearing with a given value.\n\n### .z_score(x, mean, standard_deviation)\n\nThe standard score is the number of standard deviations an observation\nor datum is above or below the mean.\n\n### .standard_normal_table\n\nA [standard normal table](http://en.wikipedia.org/wiki/Standard_normal_table) from\nwhich to pull values of Φ (phi).\n\n## Regression\n\n### .linear_regression()\n\nCreate a new linear regression solver.\n\n#### .data([[1, 1], [2, 2]])\n\nSet the data of a linear regression. The input is a two-dimensional array of numbers, which are treated as coordinates, like `[[x, y], [x1, y1]]`.\n\n#### .line()\n\nGet the linear regression line: this returns a function that you can\ngive `x` values and it will return `y` values. Internally, this uses the `m()`\nand `b()` values and the classic `y = mx + b` equation.\n\n    var linear_regression_line = ss.linear_regression()\n        .data([[0, 1], [2, 2], [3, 3]]).line();\n    linear_regression_line(5);\n\n#### .m()\n\nJust get the slope of the fitted regression line, the `m` component of the full\nline equation. Returns a number.\n\n#### .b()\n\nJust get the y-intercept of the fitted regression line, the `b` component\nof the line equation. Returns a number.\n\n## Classification\n\n### .bayesian()\n\nCreate a naïve bayesian classifier.\n\n### .train(item, category)\n\nTrain the classifier to classify a certain item, given as an object with keys,\nto be in a certain category, given as a string.\n\n### .score(item)\n\nGet the classifications of a certain item, given as an object of\n`category -> score` mappings.\n\n    var bayes = ss.bayesian();\n    bayes.train({ species: 'Cat' }, 'animal');\n    bayes.score({ species: 'Cat' });\n    // { animal: 1 }\n\n\n\n---\n\n## [Literate Source](http://macwright.org/simple-statistics/)\n\n## Usage\n\nTo use it in browsers, grab [simple_statistics.js](https://raw.github.com/tmcw/simple-statistics/master/src/simple_statistics.js).\nTo use it in node, install it with [npm](https://npmjs.org/) or add it to your package.json.\n\n    npm install simple-statistics\n\nTo use it with [component](https://github.com/component/component),\n\n    component install tmcw/simple-statistics\n\nTo use it with [bower](http://bower.io/),\n\n    bower install simple-statistics\n\n## Basic Descriptive Statistics\n\n```javascript\n// Require simple statistics\nvar ss = require('simple-statistics');\n\n// The input is a simple array\nvar list = [1, 2, 3];\n\n// Many different descriptive statistics are supported\nvar sum = ss.sum(list),\n    mean = ss.mean(list),\n    min = ss.min(list),\n    geometric_mean = ss.geometric_mean(list),\n    max = ss.max(list),\n    quantile = ss.quantile(0.25);\n```\n\n## Linear Regression\n\n```javascript\n// For a linear regression, it's a two-dimensional array\nvar data = [ [1, 2], [2, 3] ];\n\n// simple-statistics can produce a linear regression and return\n// a friendly javascript function for the line.\nvar line = ss.linear_regression()\n    .data(data)\n    .line();\n\n// get a point along the line function\nline(0);\n\nvar line = ss.linear_regression()\n\n// Get the r-squared value of the line estimation\nss.r_squared(data, line);\n```\n\n### Bayesian Classifier\n\n```javascript\nvar bayes = ss.bayesian();\nbayes.train({ species: 'Cat' }, 'animal');\nbayes.score({ species: 'Cat' });\n// { animal: 1 }\n```\n\n### Mixin Style\n\n_This is **optional** and not used by default. You can opt-in to mixins\nwith `ss.mixin()`._\n\nThis mixes `simple-statistics` methods into the Array prototype - note that\n[extending native objects](http://perfectionkills.com/extending-built-in-native-objects-evil-or-not/) is a\ntricky move.\n\nThis will _only work_ if `defineProperty` is available, which means modern browsers\nand nodejs - on IE8 and below, calling `ss.mixin()` will throw an exception.\n\n```javascript\n// mixin to Array class\nss.mixin();\n\n// The input is a simple array\nvar list = [1, 2, 3];\n\n// The same descriptive techniques as above, but in a simpler style\nvar sum = list.sum(),\n    mean = list.mean(),\n    min = list.min(),\n    max = list.max(),\n    quantile = list.quantile(0.25);\n```\n\n## Examples\n\n* [Linear regression with simple-statistics and d3js](http://bl.ocks.org/3931800)\n* [Jenks Natural Breaks with a choropleth map with d3js](http://bl.ocks.org/tmcw/4969184)\n\n# Contributors\n\n* Tom MacWright\n* [Matt Sacks](https://github.com/mattsacks)\n* Doron Linder\n* [Alexander Sicular](https://github.com/siculars)\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/tmcw/simple-statistics/issues"
  },
  "homepage": "https://github.com/tmcw/simple-statistics",
  "_id": "simple-statistics@0.8.1",
  "_from": "simple-statistics@"
}
